# Ввод/Вывод
- %d – целые числа (int)  
- %f – дробное число (float)  
- %lf – дробное число (double)  
- %c – символ (char)  
- %s – строка (char[])
- %p - указатели

## Целые числа
```C++
int n;
scanf_s("%d", &n);
printf("%d", n);
```

## Дробные числа
```C++
float f;
double d;
scanf_s("%f %lf", &f, &d);
printf("float число: %f \n double число: %lf", f, d);
```
При вводе чисел передается не значение переменной, а ее адрес - символ &.

## Строки
```C++
char str[10];
scanf_s("%s", str, 10);
printf("%s", str);
```
При вводе строки передается просто имя переменной, передается размер строки (если введем больше - строка останется пустой).

## Строки с пробелами
```C++
char str[100];
fgets(str, 100, stdin);
printf("%s", str);
```
При вводе передаем название переменной, размер строки и поток ввода - в нашем случае stdin (консоль).

# Char
*Создание*
```C++
char c = 'a';
```
Char - 1 символ, **обязательно одиночные кавычки ''.**

## Ввод и вывод
```C++
scanf_s("%c", &c);
printf("%c", c);
```

# Строки - char[]
Строки - массив символов.  
## Создание
```C++
char str[10] = "abcde";
```
*Или так*
```c++
char str[10] = { 'a', 'b', 'c', 'd', 'e' };
```
В [] указываем максимально возможный размер строки - 1. **На конце всегда символ окончания строки - '\0'.**

# Статические массивы
Массивы - набор элементов одного типа данных.
Все элементы массива хранятся в памяти последовательно.

## Массив целых чисел
```C++
int array[4] = {1, 2, 3, 4};
```
int - указываем тип значений, хранящихся в массиве.  
В [] указываем максимальное количество элементов.

## Массив дробных чисел
```C++
float array[4] = {1.2, 0.7, 6.3, 9.9};
```

## Вывод массива на экран
```C++
int array[4] = {1, 2, 3, 4};

for (int i = 0; i < 4; i++) {
    printf("%d", array[i]);
}
```
Цикл для прохода по индексам массива (от 0 до 3).  
**array[i] - обращение к элементу массива с индексом i.**

## Заполнение массива с консоли
```C++
int array[4];

for (int i = 0; i < 4; i++) {
    scanf_s("%d", &array[i]);
}
```
Цикл на количество итераций, равное количеству элементов массива.  
&array[i] - передаем адрес элемента массива, в который запишется значение.  
Числа вводятся через Enter.  

# Двумерные массивы (матрицы)
## Создание
```C++
int matrix[2][3] = {
    {1,2,3},
    {4,5,6}
};
```
Создаем матрицу из 2 строк и 3 столбцов

## Обращение к элементам
```C++
int a = matrix[0][2];
```
Получаем число из строки с индексом 0 ({1, 2, 3} с индексом 2 - число 3.  

## Вывод матрицы
```C++
for (int i = 0; i < 2; i++) {
    for (int j = 0; j < 2; j++) {
        printf("%d", matrix[i][i]);
    }
    printf("\n");
}
```
Первым циклом получаем строку матрицы - обычный массив символов.  
Втором циклом уже получаем каждый элемент строки.  
После второго цикла выводим "\n" - перенос строки, чтобы матрица была выведена построчно.

# Динамические массивы
Массивы такого типа могут быть полезны, когда размер неизвестен на момент компиляции.  
Например, размер задается пользователем.
## Создание
```C++
int* array = new int[4] {1, 2, 3, 4};
```
*Или так*
```C++
int* array{ new int[4] {1, 2, 3, 4} };
```
**new - выделение памяти.**

## Пример  
Размер массива и его значения считываются с клавиатуры:  
```C++
int size;
scanf_s("%d", &size);

int* array = new int[size];

for (int i = 0; i < size; i++) {
    scanf_s("%d", &array[i]);
}
```

## Очистка памяти
```C++
delete[] array;
```
**После окончания работы с массивом чистим выделенную память.**

## Динамические матрицы
Обычная матрица - массив, где каждый элемент является массивом. 
Динамический массив - указатель на набор элементов.
**Динамическая матрицы -динамический массив указателей.**  

Создание:
```C++
int rows = 3;
int cols = 4;

int** matrix = new int*[rows];

for (int i = 0; i < rows; ++i) {
    matrix[i] = new int[cols];
}
```
Так как создание матрицы требует цикла, удаление работает также:
```C++
for (int i = 0; i < rows; ++i) {
    delete[] matrix[i];
}
delete[] matrix;
```

# Указатели
Указатели - переменные, хранящие в себе адрес другой переменной.

## Создание
```C++
 int a = 3;
 int* pA = &a;
```
```a``` - обычная переменная типа int.  
```pA``` - указатель на a.  
```*``` - показываем, что переменная будет указателем.  
```&``` - берем адрес значения, которое хранится в a.

## Вывод указателя
```C++
 printf("%p", pA);
```
На экран будет выведено что-то вроде ```000000CF004FFC84```.  
Это адрес, по которому переменная ```a``` хранит значение ```3```.

## Вывод значения
```C++
 printf("%d", *pA);
```
```*pA``` - разыменование указателя - получаем значение переменной, на которую он указывает.

## nullptr
```nullptr``` - это указатель, указывающий на 0 адрес памяти.  
Например, после динамического выделения памяти и удаления объекта, указателю можно присвоить значение nullptr.  
Это нужно, чтобы дальнейшие действия с ним не привели к ошибкам.
```C++
int* pa = new int;
// ...
delete pa;
pa = nullptr;
```

## Массив - тоже указатель
```C++
int arr[3] = { 1, 2, 3 };
printf("%d", *arr);
```
Переменная ```arr``` сама по себе является указателем на первый элемент массива.  
Можно получать элементы массива перемещая указатель:  
```C++
printf("%d", *arr);
printf("%d", *(arr + 1));
printf("%d", *(arr + 2));
```
Так будут выведены все элементы массива.

**С помощью указателей можно обходить все составные переменные - строки, массивы, матрицы.**

# Ссылки
Ссылки - переменные, хранящие в себе адрес другой переменной. (Почти как указатели).  

## Создание
```C++
int a = 5;
int& refA = a;
```
В данном примере ```refA``` ссылается на переменную ```a```.

## Доступ к значению
Чтобы получить доступ к значению, не нужно ничего делать с ссылкой (в отличие от указателей):  
```C++
int a = 5;
int& refA = a;
refA = 17;
printf("%d", refA);
```
Так мы меняем значение переменной ```a``` через ссылку.

## Ссылки на типы данных, имеющие размерность
```C++
char str[] = "Hello";
char(&strRef)[6] = str; // Ссылка на строку размером 6

int arr[5] = { 1, 2, 3, 4, 5 };
int(&arrRef)[5] = arr;  // Ссылка на массив из 5 элементов

int matrix[3][3] = {
{1, 2, 3},
{4, 5, 6},
{7, 8, 9}
};
int(&matrixRef)[3][3] = matrix; // ссылка на матрицу размером 3x3
```
**В данном случае ссылка хранит в себе целый массив, а не адрес его первого элемента (в отличие от указателей).**  
Поэтому доступ к элементам выглядит так:  
```C++
arrRef[0] = 19;
```


# Функции
Функции - блоки кода, выполняющие определенную задачу.  
Можно вызывать в любом месте программы и сколько угодно раз.  

## Создание
```C++
int f(int a, int b) {
    return a + b;
}
```
```int``` - указываем тип возвращаемого значения;  
```f(int a, int b)``` - даем название функции - ```f``` и определяем аргументы, которые она принимает;  
```return``` - указываем, что возвращает функция.  

```void``` - **не возвращать значение.**  
```C++
void func(char* str) {
    printf("Работает функция func\nПередали строку %s", str);
}
```
Функция, которая принимает строку и ничего не возвращает.  

## Передача аргументов
- Целые числа: ```int n```;  
- Дробные числа: ```float f```;  
- Символы: ```char c```;  
- Строки: ```char* str``` или ```char str[]``` (желательно вместе со строкой, передавать и её размер);  
- Массивы: ```int* arr``` или ```int arr[]``` (желательно передавать и его размер);
- Матрицы: ```int matrix[3][3]``` - здесь обязательно указывать размер;
- Динамические массивы и матрицы передаются также, как и статические.

## Возврат значений
Целые, дробные числа и символы возвращаются по значению.  
Например:  
```C++
int func() {
    return a;
}
```

Строки, массивы и матрицы возвращаются через указатель:  
```C++
char* func() {
    ...
    return str;
}
```
Чтобы после этого воспользоваться строкой, которую вернула функция:  
```C++
char* s = func();
```

## Передача аргументов по ссылке  
Передача аргументов по ссылке позволяет работать с данными напрямую: обращаться к ним, а не к их копиям.
```C++
void updateValue(int &var, int value) {
    var += value;
}

int a = 5;
updateValue(a, 10);
```
В данном примере функция прибавляет к переменной ```var``` значение ```value```.  

Этот код можно написать и так:
```C++
int updateValue(int var, int value) {
    return var + value;
}

int a = 5;
a = updateValue(a, 10);
```
Сейчас разницы никакой. Но если нужно изменить значение сразу двух переменных? Так как функция не может вернуть 2 значения, можно передавать обе переменные по ссылке:
```C++
void updateValue(int &var1, int& var2, int value1, int value2) {
    var1 += value1;
    var2 += value2;
}
```
В основном такая передача аргументов используется при работе с примитивными типами данных (int, float и тому подобные).  
Передавать массивы и матрицы по ссылке чаще всего не имеет смысла, так как мы и так передаем указатель и работаем с массивом, а не с его копией.

## Перегрузка функций
Перегрузка функции - это создание нескольких функций с разным поведением. 
Например, программа работает с целыми и дробными числами, каждое из них нужно возводить в квадрат.  
```C++
int toSquare(int a) {
    return a * a;
}

int toSquare(float a) {
    return a * a;
}
```
Мы можем написать 2 такие функции с одинаковым именем, но разными аргументами. 
Теперь можно вызывать эту функцию как для int, так и для float чисел, и компилятор автоматически определит, какая функция будет вызвана:
```C++
int a = 5;
int b = 2.5;

a = toSquare(a);
b = toSquare(b);
```
Перегрузить функцию можно не только по типам данных, но и по количеству аргументов:
```C++
nt sumNumbers(int a, int b){
    return a + b;
}

int sumNumbers(int a, int b, int c) {
    return a + b + c;
}
```
Одна и та же функция может складывать как 2, так и 3 числа.

## Рекурсия
Рекурсивные функции - функции, которые вызывают сами себя.  
** Чтобы функция не вызывала себя бесконечно и программа не зависала, обязательно должно быть условие выхода из функции.**

Например, нужно вычислить факториал числа. Можно сделать это так:
```C++
int factorial(int n) {
    int result = 1;

    for (int i = 1; i <= n; i++) {
        result *= i;
    }

    return result;
}
```

Но также мы можем написать рекурсивную функцию:
```C++
int factorial(int n) {
    if (n <= 1) {
        return 1;
    }

    return n * factorial(n - 1);
}
```
Здесь мы устанавливаем условие выхода из функции: ```n <= 1```, если оно не выполняется, функция вызывает себя же, уменьшая число на 1.  
Допустим, идет вычисление факториала числа ``4``. Вызовы функции будут следующими:  
- ```factorial(4)``` - первый вызов функции 
- ```4 * factorial(3)``` - второй вызов функции
- ```3 * factorial(2)``` - третий вызов функции
- ```2 * factorial(1)``` - четвертый вызов функции
- ```factorial(1) -> return 1``` - пятый вызов функции  
Результат будет вычисляться с конца, то есть ```1 * 2 * 3 * 4  = 24```.  

## Указатели на функции
Указатели на функцию хранят в себе адрес функции.  

Создание:
Есть функция сложения 2 чисел:
```C++
int add(int a, int b) {
    return a + b;
}
```
Указатель на нее создается так:
```C++
int (*funcPtr)(int, int) = add;
```
Сначала указываем тип данных указателя - тот же, что возвращает функция;  
Далее в скобках *имяУказателя;  
Далее в скобках типы данных аргументов, которые принимает функция.  

Теперь мы можем вызывать функцию с помощью указателя:
```C++
printf("%d", funcPtr(1, 2));
```

Часто указатели на функции нужны, когда мы передаем в функцию другую функцию как аргумент:  
```C++
int add(int a, int b) {
    return a + b;
}

int subtract(int a, int b) {
    return a - b;
}

int operation(int (*operation)(int, int), int a, int b) {
    return operation(a, b);
}
```
В этом примере у нас есть 2 функции, выполняющие операции с числами: ```add``` и ```subtract```.
Также есть функция  ```operation```, принмающая 3 аргумента: функцию, которая будет выполнять операцию, и 2 числа. (По сути первый аргумент - это указатель на функцию).

Пользоваться этим можем так:
```C++
int resultAdd = operation(add, 4, 2);
int resultSubtract = operation(subtract, 4, 2);
```

# Работа с файлами
Примеры работы с файлами используют библиотеку ```cstdio```  

## Открытие файла
Для открытия файла используется ```fopen_s```:
```C++
FILE* file;
errno_t err = fopen_s(&file, "test.txt", "r");
if (err!= 0 || file == nullptr) {
    printf("Файл не существует");
    return 1;
}
```
Для открытия файла создаем переменную типа ```FILE*```;  
При открытии создаем объект типа ```errno_t``` - ошибка, которая модет возникнуть при открытии;  
Указываем один из режимов открытия файла:
- ```r``` - чтение
- ```w``` - запись
- ```a``` - запись в конец (данные добавляются, не удаляя предыдущие)
- ```r+``` - чтение и запись
- ```w+``` - чтение и запись
- ```a+``` - чтение и запись в конец

Также сразу делаем проверку на существование файла, если его нет, переменная ```file``` не будет ни на что указывать.

## Закрытие файла
Для закрытия файла используется ```fclose```:
```C++
fclose(file);
```

## Чтение из файла
Есть несколько функция для чтения данных из файла:
- ```fgetc(FILE* stream)``` - запись символа. Аргументы: файл.
- ```fgets(char* str, int num, FILE* stream)``` - запись строки. Аргументы: строка, куда запишется, максимальный размер строки и файл для записи.
- ```fread(void* ptr, size_t size, size_t count, FILE* stream)``` - запись блока данных. Аргументы: указатель на буфер с данными, размер одного элемента, количество элементов и файл.

Например:  
```C++
FILE* file;
errno_t err = fopen_s(&file, "test.txt", "r");
if (err!= 0 || file == nullptr) {
    return 1;
}

char buffer[256];
while (fgets(buffer, sizeof(buffer), file) != nullptr) {
    printf("%s", buffer);
}

fclose(file);
return 0;
```
Здесь мы считываем данные из файла построчно и выводим их на экран

## Запись в файл
Для записи можно использовать следующие функции:
- ```fputc(int c, FILE* stream)``` - запись символа. Аргументы: символ и файл для записи.
- ```fputs(const  char* str, FILE* stream)``` - запись строки. Аргументы: строка и файл для записи.
- ```fwrite(const void* ptr, size_t size, size_t count, FILE* stream)``` - запись блока данных. Аргументы: указатель на буфер с данными, размер одного элемента, количество элементов и файл для записи.

Например:
```C++
FILE* file;
errno_t err = fopen_s(&file, "test.txt", "r");
if (err !=0 || file == nullptr) {
    return 1;
}

const char* text = "Hello, World!\n";
fputs(text, file);

fclose(file);
return 0;
```

## Полезные функции
Кроме рассмотренных функций есть еще несколько, которые могут понадобиться:  
```fseek(FILE* stream, long offset, int origin)``` - перемещение курсора в файле.
Аргументы: файл, смещение, позиция, от которой смещаемся.  
```origin``` может принимать следующие значения: SEEK_SET (начало файла), SEEK_CUR (текущая позииция), SEEK_END (конец файла).
``` C++
fseek(file, 10, SEEK_SET);
```
Смещение на 10 от начала файла.  

```ftell(FILE* stream``` - получить текущую позицию:  
``` C++
long position = ftell(file);;
```

```rewind(FILE *stream)``` - сбросить текущую позицию (вернуть в начало файла).

## Бинарные (двоичные) файлы
Бинарные файлы хранят данные в исходном виде, не преобразовывая их в текст (в отличие от ```.txt```).  
Для работы с такими файлами к режиму открытия файла добавляется ```b```.
Пример открытия бинарного файла в режиме чтения:  
```C++
fopen_s(&file, "test.bin", "rb")
```

Для обработки данных в таком файле обычно используют функции ```fread``` и ```fwrite``` описанные выше.
