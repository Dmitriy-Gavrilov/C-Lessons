# Ввод/Вывод
- %d – целые числа (int)  
- %f – дробное число (float)  
- %lf – дробное число (double)  
- %c – символ (char)  
- %s – строка (char[])
- %p - указатели

## Целые числа
```C++
int n;
scanf_s("%d", &n);
printf("%d", n);
```

## Дробные числа
```C++
float f;
double d;
scanf_s("%f %lf", &f, &d);
printf("float число: %f \n double число: %lf", f, d);
```
При вводе чисел передается не значение переменной, а ее адрес - символ &.

## Строки
```C++
char str[10];
scanf_s("%s", str, 10);
printf("%s", str);
```
При вводе строки передается просто имя переменной, передается размер строки (если введем больше - строка останется пустой).

## Строки с пробелами
```C++
char str[100];
fgets(str, 100, stdin);
printf("%s", str);
```
При вводе передаем название переменной, размер строки и поток ввода - в нашем случае stdin (консоль).

# Char
*Создание*
```C++
char c = 'a';
```
Char - 1 символ, **обязательно одиночные кавычки ''.**

## Ввод и вывод
```C++
scanf_s("%c", &c);
printf("%c", c);
```

# Строки - char[]
Строки - массив символов.  
## Создание
```C++
char str[10] = "abcde";
```
*Или так*
```c++
char str[10] = { 'a', 'b', 'c', 'd', 'e' };
```
В [] указываем максимально возможный размер строки - 1. **На конце всегда символ окончания строки - '\0'.**

# Статические массивы
Массивы - набор элементов одного типа данных.
Все элементы массива хранятся в памяти последовательно.

## Массив целых чисел
```C++
int array[4] = {1, 2, 3, 4};
```
int - указываем тип значений, хранящихся в массиве.  
В [] указываем максимальное количество элементов.

## Массив дробных чисел
```C++
float array[4] = {1.2, 0.7, 6.3, 9.9};
```

## Вывод массива на экран
```C++
int array[4] = {1, 2, 3, 4};

for (int i = 0; i < 4; i++) {
    printf("%d", array[i]);
}
```
Цикл для прохода по индексам массива (от 0 до 3).  
**array[i] - обращение к элементу массива с индексом i.**

## Заполнение массива с консоли
```C++
int array[4];

for (int i = 0; i < 4; i++) {
    scanf_s("%d", &array[i]);
}
```
Цикл на количество итераций, равное количеству элементов массива.  
&array[i] - передаем адрес элемента массива, в который запишется значение.  
Числа вводятся через Enter.  

# Двумерные массивы (матрицы)
## Создание
```C++
int matrix[2][3] = {
    {1,2,3},
    {4,5,6}
};
```
Создаем матрицу из 2 строк и 3 столбцов

## Обращение к элементам
```C++
int a = matrix[0][2];
```
Получаем число из строки с индексом 0 ({1, 2, 3} с индексом 2 - число 3.  

## Вывод матрицы
```C++
for (int i = 0; i < 2; i++) {
    for (int j = 0; j < 2; j++) {
        printf("%d", matrix[i][i]);
    }
    printf("\n");
}
```
Первым циклом получаем строку матрицы - обычный массив символов.  
Втором циклом уже получаем каждый элемент строки.  
После второго цикла выводим "\n" - перенос строки, чтобы матрица была выведена построчно.

# Динамические массивы
Массивы такого типа могут быть полезны, когда размер неизвестен на момент компиляции.  
Например, размер задается пользователем.
## Создание
```C++
int* array = new int[4] {1, 2, 3, 4};
```
*Или так*
```C++
int* array{ new int[4] {1, 2, 3, 4} };
```
**new - выделение памяти.**

## Пример  
Размер массива и его значения считываются с клавиатуры:  
```C++
int size;
scanf_s("%d", &size);

int* array = new int[size];

for (int i = 0; i < size; i++) {
    scanf_s("%d", &array[i]);
}
```

## Очистка памяти
```C++
delete[] array;
```
**После окончания работы с массивом чистим выделенную память.**

# Указатели
Указатели - переменные, хранящие в себе адрес другой переменной.

## Создание
```C++
 int a = 3;
 int* pA = &a;
```
```a``` - обычная переменная типа int.  
```pA``` - указатель на a.  
```*``` - показываем, что переменная будет указателем.  
```&``` - берем адрес значения, которое хранится в a.

## Вывод указателя
```C++
 printf("%p", pA);
```
На экран будет выведено что-то вроде ```000000CF004FFC84```.  
Это адрес, по которому переменная ```a``` хранит значение ```3```.

## Вывод значения
```C++
 printf("%d", *pA);
```
```*pA``` - разыменование указателя - получаем значение переменной, на которую он указывает.

## nullptr
```nullptr``` - это указатель, указывающий на 0 адрес памяти.  
Например, после динамического выделения памяти и удаления объекта, указателю можно присвоить значение nullptr.  
Это нужно, чтобы дальнейшие действия с ним не привели к ошибкам.
```C++
int* pa = new int;
// ...
delete pa;
pa = nullptr;
```

## Массив - тоже указатель
```C++
int arr[3] = { 1, 2, 3 };
printf("%d", *arr);
```
Переменная ```arr``` сама по себе является указателем на первый элемент массива.  
Можно получать элементы массива перемещая указатель:  
```C++
printf("%d", *arr);
printf("%d", *(arr + 1));
printf("%d", *(arr + 2));
```
Так будут выведены все элементы массива.

**С помощью указателей можно обходить все составные переменные - строки, массивы, матрицы.**

# Ссылки
Ссылки - переменные, хранящие в себе адрес другой переменной. (Почти как указатели).  

## Создание
```C++
int a = 5;
int& refA = a;
```
В данном примере ```refA``` ссылается на переменную ```a```.

## Доступ к значению
Чтобы получить доступ к значению, не нужно ничего делать с ссылкой (в отличие от указателей):  
```C++
int a = 5;
int& refA = a;
refA = 17;
printf("%d", refA);
```
Так мы меняем значение переменной ```a``` через ссылку.

## Ссылки на типы данных, имеющие размерность
```C++
char str[] = "Hello";
char(&strRef)[6] = str; // Ссылка на строку размером 6

int arr[5] = { 1, 2, 3, 4, 5 };
int(&arrRef)[5] = arr;  // Ссылка на массив из 5 элементов

int matrix[3][3] = {
{1, 2, 3},
{4, 5, 6},
{7, 8, 9}
};
int(&matrixRef)[3][3] = matrix; // ссылка на матрицу размером 3x3
```
**В данном случае ссылка хранит в себе целый массив, а не адрес его первого элемента (в отличие от указателей).**  
Поэтому доступ к элементам выглядит так:  
```C++
arrRef[0] = 19;
```


# Функции
Функции - блоки кода, выполняющие определенную задачу.  
Можно вызывать в любом месте программы и сколько угодно раз.  

## Создание
```C++
int f(int a, int b) {
    return a + b;
}
```
```int``` - указываем тип возвращаемого значения;  
```f(int a, int b)``` - даем название функции - ```f``` и определяем аргументы, которые она принимает;  
```return``` - указываем, что возвращает функция.  

```void``` - **не возвращать значение.**  
```C++
void func(char* str) {
    printf("Работает функция func\nПередали строку %s", str);
}
```
Функция, которая принимает строку и ничего не возвращает.  

## Передача аргументов
- Целые числа: ```int n```;  
- Дробные числа: ```float f```;  
- Символы: ```char c```;  
- Строки: ```char* str``` или ```char str[]``` (желательно вместе со строкой, передавать и её размер);  
- Массивы: ```int* arr``` или ```int arr[]``` (желательно передавать и его размер);
- Матрицы: ```int matrix[3][3]``` - здесь обязательно указывать размер;
- Динамические массивы и матрицы передаются также, как и статические.

## Возврат значений
Целые, дробные числа и символы возвращаются по значению.  
Например:  
```C++
int func() {
    return a;
}
```

Строки, массивы и матрицы возвращаются через указатель:  
```C++
char* func() {
    ...
    return str;
}
```
Чтобы после этого воспользоваться строкой, которую вернула функция:  
```C++
char* s = func();
```
